@using Microsoft.Extensions.Logging
@using sk.shared

<div class="position-relative" style="left: 50%; top: 50%;">
    <div class="skcard top-card @topCard?.GetCssClass() @clearAnimationCssClassTop">
    </div>
    <div class="skcard bottom-card @bottomCard?.GetCssClass() @clearAnimationCssClassBottom">
    </div>
    <div class="skcard left-card @leftCard?.GetCssClass() @clearAnimationCssClassLeft">
    </div>
    <div class="skcard right-card @rightCard?.GetCssClass() @clearAnimationCssClassRight">
    </div>
</div>
@if (!string.IsNullOrEmpty(cardAnimationCssClass))
{
    <div class="skcard @currentCard?.Card.GetCssClass() @cardAnimationCssClass">
    </div>
}

@code {
    [CascadingParameter]
    public PublicGameState PublicGameState { get; set; } = default!;

    protected override void OnInitialized()
    {
        base.OnInitialized();
    }

    Card? bottomCard;
    Card? leftCard;
    Card? topCard;
    Card? rightCard;
    PlayerCard? currentCard;
    string? clearAnimationCssClassBottom;
    string? clearAnimationCssClassLeft;
    string? clearAnimationCssClassTop;
    string? clearAnimationCssClassRight;

    private readonly Queue<PlayerCard> _cardAnimationQueue = new Queue<PlayerCard>();
    private bool _isProcessingQueue;
    private bool _isClearing; // New flag for clearing status


    string? cardAnimationCssClass => currentCard == null ? null : currentCard.Position switch
    {
        0 => "playbottomcard",
        1 => "playleftcard",
        2 => "playtopcard",
        3 => "playrightcard",
        _ => null
    };

    public void AddCard(PlayerCard playerCard, List<PlayerViewInfo> playersByView)
    {
        _cardAnimationQueue.Enqueue(playerCard);
        // Only start processing if not already processing AND not currently clearing
        if (!_isProcessingQueue && !_isClearing)
        {
            _ = ProcessCardQueue(playersByView);
        }
    }

    private async Task ProcessCardQueue(List<PlayerViewInfo> playersByView)
    {
        _isProcessingQueue = true;

        // Wait until clearing is finished before processing cards
        while (_isClearing)
        {
            await Task.Delay(50); // Small delay to avoid busy-waiting
        }

        while (_cardAnimationQueue.Any())
        {
            // Re-check if clearing started while waiting for next card
            if (_isClearing)
            {
                // Clearing started, stop processing and let Clear handle re-triggering if needed
                _isProcessingQueue = false;
                return;
            }

            var playerCard = _cardAnimationQueue.Dequeue();

            // Set currentCard for animation
            currentCard = playerCard;
            await InvokeAsync(StateHasChanged);

            // Wait for animation to complete
            await Task.Delay(800);

            // Move card to static position and clear animated card
            await InvokeAsync(() =>
            {
                _ = playerCard.Position switch
                {
                    0 => bottomCard = playerCard.Card,
                    1 => leftCard = playerCard.Card,
                    2 => topCard = playerCard.Card,
                    3 => rightCard = playerCard.Card,
                    _ => null,
                };
                currentCard = null;
                StateHasChanged();
            });
        }

        if (bottomCard != null && leftCard != null && topCard != null && rightCard != null)
        {
            await Task.Delay(800);
            await Clear(PublicGameState.ActivePlayer, playersByView); // Pass playersByView here
        }
        _isProcessingQueue = false;

        // If cards were added to the queue while clearing, and clearing is now done, restart processing
        if (_cardAnimationQueue.Any() && !_isClearing)
        {
            _ = ProcessCardQueue(playersByView);
        }
    }


    public async Task Clear(int position, List<PlayerViewInfo> playersByView) // Add playersByView parameter
    {
        _isClearing = true; // Set clearing flag

        if (bottomCard != null) clearAnimationCssClassBottom = $"clear-to-pos{position}-from-bottom";
        if (leftCard != null) clearAnimationCssClassLeft = $"clear-to-pos{position}-from-left";
        if (topCard != null) clearAnimationCssClassTop = $"clear-to-pos{position}-from-top";
        if (rightCard != null) clearAnimationCssClassRight = $"clear-to-pos{position}-from-right";

        await InvokeAsync(StateHasChanged);

        await Task.Delay(800); // Animation duration, should match CSS

        await InvokeAsync(() =>
        {
            bottomCard = null;
            leftCard = null;
            topCard = null;
            rightCard = null;
            currentCard = null; // Ensure current card is also cleared

            clearAnimationCssClassBottom = null;
            clearAnimationCssClassLeft = null;
            clearAnimationCssClassTop = null;
            clearAnimationCssClassRight = null;

            StateHasChanged();
        });

        _isClearing = false; // Clear clearing flag

        // After clearing, check if any cards are waiting in the queue
        if (_cardAnimationQueue.Any() && !_isProcessingQueue)
        {
            _ = ProcessCardQueue(playersByView); // Pass playersByView here
        }
    }
}